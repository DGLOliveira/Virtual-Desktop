"use strict";(self.webpackChunkpc=self.webpackChunkpc||[]).push([[4150],{2717:(e,t,n)=>{n.d(t,{N:()=>h});var o=n(8168),a=n(749),i=n(5043),r=n(9408),s=Object.defineProperty,c=(e,t,n)=>(((e,t,n)=>{t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!==typeof t?t+"":t,n),n);const l=new r.Ray,u=new r.Plane,m=Math.cos(Math.PI/180*70),d=(e,t)=>(e%t+t)%t;class p extends r.EventDispatcher{constructor(e,t){super(),c(this,"object"),c(this,"domElement"),c(this,"enabled",!0),c(this,"target",new r.Vector3),c(this,"minDistance",0),c(this,"maxDistance",1/0),c(this,"minZoom",0),c(this,"maxZoom",1/0),c(this,"minPolarAngle",0),c(this,"maxPolarAngle",Math.PI),c(this,"minAzimuthAngle",-1/0),c(this,"maxAzimuthAngle",1/0),c(this,"enableDamping",!1),c(this,"dampingFactor",.05),c(this,"enableZoom",!0),c(this,"zoomSpeed",1),c(this,"enableRotate",!0),c(this,"rotateSpeed",1),c(this,"enablePan",!0),c(this,"panSpeed",1),c(this,"screenSpacePanning",!0),c(this,"keyPanSpeed",7),c(this,"zoomToCursor",!1),c(this,"autoRotate",!1),c(this,"autoRotateSpeed",2),c(this,"reverseOrbit",!1),c(this,"reverseHorizontalOrbit",!1),c(this,"reverseVerticalOrbit",!1),c(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),c(this,"mouseButtons",{LEFT:r.MOUSE.ROTATE,MIDDLE:r.MOUSE.DOLLY,RIGHT:r.MOUSE.PAN}),c(this,"touches",{ONE:r.TOUCH.ROTATE,TWO:r.TOUCH.DOLLY_PAN}),c(this,"target0"),c(this,"position0"),c(this,"zoom0"),c(this,"_domElementKeyEvents",null),c(this,"getPolarAngle"),c(this,"getAzimuthalAngle"),c(this,"setPolarAngle"),c(this,"setAzimuthalAngle"),c(this,"getDistance"),c(this,"getZoomScale"),c(this,"listenToKeyEvents"),c(this,"stopListenToKeyEvents"),c(this,"saveState"),c(this,"reset"),c(this,"update"),c(this,"connect"),c(this,"dispose"),c(this,"dollyIn"),c(this,"dollyOut"),c(this,"getScale"),c(this,"setScale"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>f.phi,this.getAzimuthalAngle=()=>f.theta,this.setPolarAngle=e=>{let t=d(e,2*Math.PI),o=f.phi;o<0&&(o+=2*Math.PI),t<0&&(t+=2*Math.PI);let a=Math.abs(t-o);2*Math.PI-a<a&&(t<o?t+=2*Math.PI:o+=2*Math.PI),v.phi=t-o,n.update()},this.setAzimuthalAngle=e=>{let t=d(e,2*Math.PI),o=f.theta;o<0&&(o+=2*Math.PI),t<0&&(t+=2*Math.PI);let a=Math.abs(t-o);2*Math.PI-a<a&&(t<o?t+=2*Math.PI:o+=2*Math.PI),v.theta=t-o,n.update()},this.getDistance=()=>n.object.position.distanceTo(n.target),this.listenToKeyEvents=e=>{e.addEventListener("keydown",ne),this._domElementKeyEvents=e},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",ne),this._domElementKeyEvents=null},this.saveState=()=>{n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=()=>{n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(o),n.update(),p=s.NONE},this.update=(()=>{const t=new r.Vector3,a=new r.Vector3(0,1,0),i=(new r.Quaternion).setFromUnitVectors(e.up,a),c=i.clone().invert(),d=new r.Vector3,y=new r.Quaternion,E=2*Math.PI;return function(){const w=n.object.position;i.setFromUnitVectors(e.up,a),c.copy(i).invert(),t.copy(w).sub(n.target),t.applyQuaternion(i),f.setFromVector3(t),n.autoRotate&&p===s.NONE&&_(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(f.theta+=v.theta*n.dampingFactor,f.phi+=v.phi*n.dampingFactor):(f.theta+=v.theta,f.phi+=v.phi);let x=n.minAzimuthAngle,P=n.maxAzimuthAngle;isFinite(x)&&isFinite(P)&&(x<-Math.PI?x+=E:x>Math.PI&&(x-=E),P<-Math.PI?P+=E:P>Math.PI&&(P-=E),f.theta=x<=P?Math.max(x,Math.min(P,f.theta)):f.theta>(x+P)/2?Math.max(x,f.theta):Math.min(P,f.theta)),f.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,f.phi)),f.makeSafe(),!0===n.enableDamping?n.target.addScaledVector(b,n.dampingFactor):n.target.add(b),n.zoomToCursor&&D||n.object.isOrthographicCamera?f.radius=Y(f.radius):f.radius=Y(f.radius*g),t.setFromSpherical(f),t.applyQuaternion(c),w.copy(n.target).add(t),n.object.matrixAutoUpdate||n.object.updateMatrix(),n.object.lookAt(n.target),!0===n.enableDamping?(v.theta*=1-n.dampingFactor,v.phi*=1-n.dampingFactor,b.multiplyScalar(1-n.dampingFactor)):(v.set(0,0,0),b.set(0,0,0));let M=!1;if(n.zoomToCursor&&D){let o=null;if(n.object instanceof r.PerspectiveCamera&&n.object.isPerspectiveCamera){const e=t.length();o=Y(e*g);const a=e-o;n.object.position.addScaledVector(T,a),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const e=new r.Vector3(A.x,A.y,0);e.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/g)),n.object.updateProjectionMatrix(),M=!0;const a=new r.Vector3(A.x,A.y,0);a.unproject(n.object),n.object.position.sub(a).add(e),n.object.updateMatrixWorld(),o=t.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;null!==o&&(n.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(o).add(n.object.position):(l.origin.copy(n.object.position),l.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(l.direction))<m?e.lookAt(n.target):(u.setFromNormalAndCoplanarPoint(n.object.up,n.target),l.intersectPlane(u,n.target))))}else n.object instanceof r.OrthographicCamera&&n.object.isOrthographicCamera&&(M=1!==g,M&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/g)),n.object.updateProjectionMatrix()));return g=1,D=!1,!!(M||d.distanceToSquared(n.object.position)>h||8*(1-y.dot(n.object.quaternion))>h)&&(n.dispatchEvent(o),d.copy(n.object.position),y.copy(n.object.quaternion),M=!1,!0)}})(),this.connect=e=>{n.domElement=e,n.domElement.style.touchAction="none",n.domElement.addEventListener("contextmenu",oe),n.domElement.addEventListener("pointerdown",$),n.domElement.addEventListener("pointercancel",ee),n.domElement.addEventListener("wheel",te)},this.dispose=()=>{var e,t,o,a,i,r;n.domElement&&(n.domElement.style.touchAction="auto"),null==(e=n.domElement)||e.removeEventListener("contextmenu",oe),null==(t=n.domElement)||t.removeEventListener("pointerdown",$),null==(o=n.domElement)||o.removeEventListener("pointercancel",ee),null==(a=n.domElement)||a.removeEventListener("wheel",te),null==(i=n.domElement)||i.ownerDocument.removeEventListener("pointermove",J),null==(r=n.domElement)||r.ownerDocument.removeEventListener("pointerup",ee),null!==n._domElementKeyEvents&&n._domElementKeyEvents.removeEventListener("keydown",ne)};const n=this,o={type:"change"},a={type:"start"},i={type:"end"},s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let p=s.NONE;const h=1e-6,f=new r.Spherical,v=new r.Spherical;let g=1;const b=new r.Vector3,y=new r.Vector2,E=new r.Vector2,w=new r.Vector2,x=new r.Vector2,P=new r.Vector2,M=new r.Vector2,S=new r.Vector2,C=new r.Vector2,O=new r.Vector2,T=new r.Vector3,A=new r.Vector2;let D=!1;const j=[],L={};function R(){return Math.pow(.95,n.zoomSpeed)}function _(e){n.reverseOrbit||n.reverseHorizontalOrbit?v.theta+=e:v.theta-=e}function N(e){n.reverseOrbit||n.reverseVerticalOrbit?v.phi+=e:v.phi-=e}const z=(()=>{const e=new r.Vector3;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),b.add(e)}})(),I=(()=>{const e=new r.Vector3;return function(t,o){!0===n.screenSpacePanning?e.setFromMatrixColumn(o,1):(e.setFromMatrixColumn(o,0),e.crossVectors(n.object.up,e)),e.multiplyScalar(t),b.add(e)}})(),V=(()=>{const e=new r.Vector3;return function(t,o){const a=n.domElement;if(a&&n.object instanceof r.PerspectiveCamera&&n.object.isPerspectiveCamera){const i=n.object.position;e.copy(i).sub(n.target);let r=e.length();r*=Math.tan(n.object.fov/2*Math.PI/180),z(2*t*r/a.clientHeight,n.object.matrix),I(2*o*r/a.clientHeight,n.object.matrix)}else a&&n.object instanceof r.OrthographicCamera&&n.object.isOrthographicCamera?(z(t*(n.object.right-n.object.left)/n.object.zoom/a.clientWidth,n.object.matrix),I(o*(n.object.top-n.object.bottom)/n.object.zoom/a.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}})();function k(e){n.object instanceof r.PerspectiveCamera&&n.object.isPerspectiveCamera||n.object instanceof r.OrthographicCamera&&n.object.isOrthographicCamera?g=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function U(e){k(g/e)}function F(e){k(g*e)}function H(e){if(!n.zoomToCursor||!n.domElement)return;D=!0;const t=n.domElement.getBoundingClientRect(),o=e.clientX-t.left,a=e.clientY-t.top,i=t.width,r=t.height;A.x=o/i*2-1,A.y=-a/r*2+1,T.set(A.x,A.y,1).unproject(n.object).sub(n.object.position).normalize()}function Y(e){return Math.max(n.minDistance,Math.min(n.maxDistance,e))}function B(e){y.set(e.clientX,e.clientY)}function W(e){x.set(e.clientX,e.clientY)}function Z(){if(1==j.length)y.set(j[0].pageX,j[0].pageY);else{const e=.5*(j[0].pageX+j[1].pageX),t=.5*(j[0].pageY+j[1].pageY);y.set(e,t)}}function X(){if(1==j.length)x.set(j[0].pageX,j[0].pageY);else{const e=.5*(j[0].pageX+j[1].pageX),t=.5*(j[0].pageY+j[1].pageY);x.set(e,t)}}function K(){const e=j[0].pageX-j[1].pageX,t=j[0].pageY-j[1].pageY,n=Math.sqrt(e*e+t*t);S.set(0,n)}function G(e){if(1==j.length)E.set(e.pageX,e.pageY);else{const t=ie(e),n=.5*(e.pageX+t.x),o=.5*(e.pageY+t.y);E.set(n,o)}w.subVectors(E,y).multiplyScalar(n.rotateSpeed);const t=n.domElement;t&&(_(2*Math.PI*w.x/t.clientHeight),N(2*Math.PI*w.y/t.clientHeight)),y.copy(E)}function q(e){if(1==j.length)P.set(e.pageX,e.pageY);else{const t=ie(e),n=.5*(e.pageX+t.x),o=.5*(e.pageY+t.y);P.set(n,o)}M.subVectors(P,x).multiplyScalar(n.panSpeed),V(M.x,M.y),x.copy(P)}function Q(e){const t=ie(e),o=e.pageX-t.x,a=e.pageY-t.y,i=Math.sqrt(o*o+a*a);C.set(0,i),O.set(0,Math.pow(C.y/S.y,n.zoomSpeed)),U(O.y),S.copy(C)}function $(e){var t,o;!1!==n.enabled&&(0===j.length&&(null==(t=n.domElement)||t.ownerDocument.addEventListener("pointermove",J),null==(o=n.domElement)||o.ownerDocument.addEventListener("pointerup",ee)),function(e){j.push(e)}(e),"touch"===e.pointerType?function(e){switch(ae(e),j.length){case 1:switch(n.touches.ONE){case r.TOUCH.ROTATE:if(!1===n.enableRotate)return;Z(),p=s.TOUCH_ROTATE;break;case r.TOUCH.PAN:if(!1===n.enablePan)return;X(),p=s.TOUCH_PAN;break;default:p=s.NONE}break;case 2:switch(n.touches.TWO){case r.TOUCH.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&K(),n.enablePan&&X(),p=s.TOUCH_DOLLY_PAN;break;case r.TOUCH.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&K(),n.enableRotate&&Z(),p=s.TOUCH_DOLLY_ROTATE;break;default:p=s.NONE}break;default:p=s.NONE}p!==s.NONE&&n.dispatchEvent(a)}(e):function(e){let t;switch(e.button){case 0:t=n.mouseButtons.LEFT;break;case 1:t=n.mouseButtons.MIDDLE;break;case 2:t=n.mouseButtons.RIGHT;break;default:t=-1}switch(t){case r.MOUSE.DOLLY:if(!1===n.enableZoom)return;!function(e){H(e),S.set(e.clientX,e.clientY)}(e),p=s.DOLLY;break;case r.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enablePan)return;W(e),p=s.PAN}else{if(!1===n.enableRotate)return;B(e),p=s.ROTATE}break;case r.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enableRotate)return;B(e),p=s.ROTATE}else{if(!1===n.enablePan)return;W(e),p=s.PAN}break;default:p=s.NONE}p!==s.NONE&&n.dispatchEvent(a)}(e))}function J(e){!1!==n.enabled&&("touch"===e.pointerType?function(e){switch(ae(e),p){case s.TOUCH_ROTATE:if(!1===n.enableRotate)return;G(e),n.update();break;case s.TOUCH_PAN:if(!1===n.enablePan)return;q(e),n.update();break;case s.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(e){n.enableZoom&&Q(e),n.enablePan&&q(e)}(e),n.update();break;case s.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(e){n.enableZoom&&Q(e),n.enableRotate&&G(e)}(e),n.update();break;default:p=s.NONE}}(e):function(e){if(!1===n.enabled)return;switch(p){case s.ROTATE:if(!1===n.enableRotate)return;!function(e){E.set(e.clientX,e.clientY),w.subVectors(E,y).multiplyScalar(n.rotateSpeed);const t=n.domElement;t&&(_(2*Math.PI*w.x/t.clientHeight),N(2*Math.PI*w.y/t.clientHeight)),y.copy(E),n.update()}(e);break;case s.DOLLY:if(!1===n.enableZoom)return;!function(e){C.set(e.clientX,e.clientY),O.subVectors(C,S),O.y>0?U(R()):O.y<0&&F(R()),S.copy(C),n.update()}(e);break;case s.PAN:if(!1===n.enablePan)return;!function(e){P.set(e.clientX,e.clientY),M.subVectors(P,x).multiplyScalar(n.panSpeed),V(M.x,M.y),x.copy(P),n.update()}(e)}}(e))}function ee(e){var t,o,a;!function(e){delete L[e.pointerId];for(let t=0;t<j.length;t++)if(j[t].pointerId==e.pointerId)return void j.splice(t,1)}(e),0===j.length&&(null==(t=n.domElement)||t.releasePointerCapture(e.pointerId),null==(o=n.domElement)||o.ownerDocument.removeEventListener("pointermove",J),null==(a=n.domElement)||a.ownerDocument.removeEventListener("pointerup",ee)),n.dispatchEvent(i),p=s.NONE}function te(e){!1===n.enabled||!1===n.enableZoom||p!==s.NONE&&p!==s.ROTATE||(e.preventDefault(),n.dispatchEvent(a),function(e){H(e),e.deltaY<0?F(R()):e.deltaY>0&&U(R()),n.update()}(e),n.dispatchEvent(i))}function ne(e){!1!==n.enabled&&!1!==n.enablePan&&function(e){let t=!1;switch(e.code){case n.keys.UP:V(0,n.keyPanSpeed),t=!0;break;case n.keys.BOTTOM:V(0,-n.keyPanSpeed),t=!0;break;case n.keys.LEFT:V(n.keyPanSpeed,0),t=!0;break;case n.keys.RIGHT:V(-n.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),n.update())}(e)}function oe(e){!1!==n.enabled&&e.preventDefault()}function ae(e){let t=L[e.pointerId];void 0===t&&(t=new r.Vector2,L[e.pointerId]=t),t.set(e.pageX,e.pageY)}function ie(e){const t=e.pointerId===j[0].pointerId?j[1]:j[0];return L[t.pointerId]}this.dollyIn=function(){F(arguments.length>0&&void 0!==arguments[0]?arguments[0]:R()),n.update()},this.dollyOut=function(){U(arguments.length>0&&void 0!==arguments[0]?arguments[0]:R()),n.update()},this.getScale=()=>g,this.setScale=e=>{k(e),n.update()},this.getZoomScale=()=>R(),void 0!==t&&this.connect(t),this.update()}}const h=i.forwardRef(((e,t)=>{let{makeDefault:n,camera:r,regress:s,domElement:c,enableDamping:l=!0,keyEvents:u=!1,onChange:m,onStart:d,onEnd:h,...f}=e;const v=(0,a.D)((e=>e.invalidate)),g=(0,a.D)((e=>e.camera)),b=(0,a.D)((e=>e.gl)),y=(0,a.D)((e=>e.events)),E=(0,a.D)((e=>e.setEvents)),w=(0,a.D)((e=>e.set)),x=(0,a.D)((e=>e.get)),P=(0,a.D)((e=>e.performance)),M=r||g,S=c||y.connected||b.domElement,C=i.useMemo((()=>new p(M)),[M]);return(0,a.F)((()=>{C.enabled&&C.update()}),-1),i.useEffect((()=>(u&&C.connect(!0===u?S:u),C.connect(S),()=>{C.dispose()})),[u,S,s,C,v]),i.useEffect((()=>{const e=e=>{v(),s&&P.regress(),m&&m(e)},t=e=>{d&&d(e)},n=e=>{h&&h(e)};return C.addEventListener("change",e),C.addEventListener("start",t),C.addEventListener("end",n),()=>{C.removeEventListener("start",t),C.removeEventListener("end",n),C.removeEventListener("change",e)}}),[m,d,h,C,v,E]),i.useEffect((()=>{if(n){const e=x().controls;return w({controls:C}),()=>w({controls:e})}}),[n,C]),i.createElement("primitive",(0,o.A)({ref:t,object:C,enableDamping:l},f))}))},2474:(e,t,n)=>{n.d(t,{m:()=>p});var o=n(8168),a=n(5043),i=n(9408),r=n(8798),s=Object.defineProperty,c=(e,t,n)=>(((e,t,n)=>{t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!==typeof t?t+"":t,n),n);const l={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new i.Vector3},up:{value:new i.Vector3(0,1,0)}},vertexShader:"\n      uniform vec3 sunPosition;\n      uniform float rayleigh;\n      uniform float turbidity;\n      uniform float mieCoefficient;\n      uniform vec3 up;\n\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      // constants for atmospheric scattering\n      const float e = 2.71828182845904523536028747135266249775724709369995957;\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      // wavelength of used primaries, according to preetham\n      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n      // mie stuff\n      // K coefficient for the primaries\n      const float v = 4.0;\n      const vec3 K = vec3( 0.686, 0.678, 0.666 );\n      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n      // earth shadow hack\n      // cutoffAngle = pi / 1.95;\n      const float cutoffAngle = 1.6110731556870734;\n      const float steepness = 1.5;\n      const float EE = 1000.0;\n\n      float sunIntensity( float zenithAngleCos ) {\n        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n      }\n\n      vec3 totalMie( float T ) {\n        float c = ( 0.2 * T ) * 10E-18;\n        return 0.434 * c * MieConst;\n      }\n\n      void main() {\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        gl_Position.z = gl_Position.w; // set z to camera.far\n\n        vSunDirection = normalize( sunPosition );\n\n        vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n      // extinction (absorbtion + out scattering)\n      // rayleigh coefficients\n        vBetaR = totalRayleigh * rayleighCoefficient;\n\n      // mie coefficients\n        vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n      }\n    ",fragmentShader:`\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      uniform float mieDirectionalG;\n      uniform vec3 up;\n\n      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n      // constants for atmospheric scattering\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      const float n = 1.0003; // refractive index of air\n      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n      // optical length at zenith for molecules\n      const float rayleighZenithLength = 8.4E3;\n      const float mieZenithLength = 1.25E3;\n      // 66 arc seconds -> degrees, and the cosine of that\n      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n      // 3.0 / ( 16.0 * pi )\n      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n      // 1.0 / ( 4.0 * pi )\n      const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n      float rayleighPhase( float cosTheta ) {\n        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n      }\n\n      float hgPhase( float cosTheta, float g ) {\n        float g2 = pow( g, 2.0 );\n        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n      }\n\n      void main() {\n\n        vec3 direction = normalize( vWorldPosition - cameraPos );\n\n      // optical length\n      // cutoff angle at 90 to avoid singularity in next formula.\n        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n        float sR = rayleighZenithLength * inverse;\n        float sM = mieZenithLength * inverse;\n\n      // combined extinction factor\n        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n      // in scattering\n        float cosTheta = dot( direction, vSunDirection );\n\n        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n        vec3 betaRTheta = vBetaR * rPhase;\n\n        float mPhase = hgPhase( cosTheta, mieDirectionalG );\n        vec3 betaMTheta = vBetaM * mPhase;\n\n        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n      // nightsky\n        float theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n        float phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n        vec3 L0 = vec3( 0.1 ) * Fex;\n\n      // composition + solar disc\n        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n        gl_FragColor = vec4( retColor, 1.0 );\n\n      #include <tonemapping_fragment>\n      #include <${r.r>=154?"colorspace_fragment":"encodings_fragment"}>\n\n      }\n    `},u=new i.ShaderMaterial({name:"SkyShader",fragmentShader:l.fragmentShader,vertexShader:l.vertexShader,uniforms:i.UniformsUtils.clone(l.uniforms),side:i.BackSide,depthWrite:!1});class m extends i.Mesh{constructor(){super(new i.BoxGeometry(1,1,1),u)}}function d(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new i.Vector3;const o=Math.PI*(e-.5),a=2*Math.PI*(t-.5);return n.x=Math.cos(a),n.y=Math.sin(o),n.z=Math.sin(a),n}c(m,"SkyShader",l),c(m,"material",u);const p=a.forwardRef(((e,t)=>{let{inclination:n=.6,azimuth:r=.1,distance:s=1e3,mieCoefficient:c=.005,mieDirectionalG:l=.8,rayleigh:u=.5,turbidity:p=10,sunPosition:h=d(n,r),...f}=e;const v=a.useMemo((()=>(new i.Vector3).setScalar(s)),[s]),[g]=a.useState((()=>new m));return a.createElement("primitive",(0,o.A)({object:g,ref:t,"material-uniforms-mieCoefficient-value":c,"material-uniforms-mieDirectionalG-value":l,"material-uniforms-rayleigh-value":u,"material-uniforms-sunPosition-value":h,"material-uniforms-turbidity-value":p,scale:v},f))}))},678:(e,t,n)=>{n.d(t,{A:()=>l});var o=n(5043),a=n(749),i=n(9408);const r=(()=>parseInt(i.REVISION.replace(/\D+/g,"")))();class s extends i.ShaderMaterial{constructor(){super({uniforms:{time:{value:0},fade:{value:1}},vertexShader:"\n      uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }",fragmentShader:`\n      uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n\n        #include <tonemapping_fragment>\n\t      #include <${r>=154?"colorspace_fragment":"encodings_fragment"}>\n      }`})}}const c=e=>(new i.Vector3).setFromSpherical(new i.Spherical(e,Math.acos(1-2*Math.random()),2*Math.random()*Math.PI)),l=o.forwardRef(((e,t)=>{let{radius:n=100,depth:r=50,count:l=5e3,saturation:u=0,factor:m=4,fade:d=!1,speed:p=1}=e;const h=o.useRef(),[f,v,g]=o.useMemo((()=>{const e=[],t=[],o=Array.from({length:l},(()=>(.5+.5*Math.random())*m)),a=new i.Color;let s=n+r;const d=r/l;for(let n=0;n<l;n++)s-=d*Math.random(),e.push(...c(s).toArray()),a.setHSL(n/l,u,.9),t.push(a.r,a.g,a.b);return[new Float32Array(e),new Float32Array(t),new Float32Array(o)]}),[l,r,m,n,u]);(0,a.F)((e=>h.current&&(h.current.uniforms.time.value=e.clock.getElapsedTime()*p)));const[b]=o.useState((()=>new s));return o.createElement("points",{ref:t},o.createElement("bufferGeometry",null,o.createElement("bufferAttribute",{attach:"attributes-position",args:[f,3]}),o.createElement("bufferAttribute",{attach:"attributes-color",args:[v,3]}),o.createElement("bufferAttribute",{attach:"attributes-size",args:[g,1]})),o.createElement("primitive",{ref:h,object:b,attach:"material",blending:i.AdditiveBlending,"uniforms-fade-value":d,depthWrite:!1,transparent:!0,vertexColors:!0}))}))},2585:(e,t,n)=>{n.d(t,{Zc:()=>r});var o=n(8168),a=n(5043);function i(e,t){const n=e+"Geometry";return a.forwardRef(((e,i)=>{let{args:r,children:s,...c}=e;const l=a.useRef(null);return a.useImperativeHandle(i,(()=>l.current)),a.useLayoutEffect((()=>{null==t||t(l.current)})),a.createElement("mesh",(0,o.A)({ref:l},c),a.createElement(n,{attach:"geometry",args:r}),s)}))}const r=i("plane")},6214:(e,t,n)=>{n.d(t,{E:()=>a});var o=n(9408);class a extends o.Mesh{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(e),this.isWater=!0;const n=this,a=void 0!==t.textureWidth?t.textureWidth:512,i=void 0!==t.textureHeight?t.textureHeight:512,r=void 0!==t.clipBias?t.clipBias:0,s=void 0!==t.alpha?t.alpha:1,c=void 0!==t.time?t.time:0,l=void 0!==t.waterNormals?t.waterNormals:null,u=void 0!==t.sunDirection?t.sunDirection:new o.Vector3(.70707,.70707,0),m=new o.Color(void 0!==t.sunColor?t.sunColor:16777215),d=new o.Color(void 0!==t.waterColor?t.waterColor:8355711),p=void 0!==t.eye?t.eye:new o.Vector3(0,0,0),h=void 0!==t.distortionScale?t.distortionScale:20,f=void 0!==t.side?t.side:o.FrontSide,v=void 0!==t.fog&&t.fog,g=new o.Plane,b=new o.Vector3,y=new o.Vector3,E=new o.Vector3,w=new o.Matrix4,x=new o.Vector3(0,0,-1),P=new o.Vector4,M=new o.Vector3,S=new o.Vector3,C=new o.Vector4,O=new o.Matrix4,T=new o.PerspectiveCamera,A=new o.WebGLRenderTarget(a,i),D={uniforms:o.UniformsUtils.merge([o.UniformsLib.fog,o.UniformsLib.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new o.Matrix4},sunColor:{value:new o.Color(8355711)},sunDirection:{value:new o.Vector3(.70707,.70707,0)},eye:{value:new o.Vector3},waterColor:{value:new o.Color(5592405)}}]),vertexShader:"\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}",fragmentShader:`\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(o.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n\t\t\t\t\t#include <fog_fragment>\t\n\t\t\t\t}`},j=new o.ShaderMaterial({fragmentShader:D.fragmentShader,vertexShader:D.vertexShader,uniforms:o.UniformsUtils.clone(D.uniforms),lights:!0,side:f,fog:v});j.uniforms.mirrorSampler.value=A.texture,j.uniforms.textureMatrix.value=O,j.uniforms.alpha.value=s,j.uniforms.time.value=c,j.uniforms.normalSampler.value=l,j.uniforms.sunColor.value=m,j.uniforms.waterColor.value=d,j.uniforms.sunDirection.value=u,j.uniforms.distortionScale.value=h,j.uniforms.eye.value=p,n.material=j,n.onBeforeRender=function(e,t,o){if(y.setFromMatrixPosition(n.matrixWorld),E.setFromMatrixPosition(o.matrixWorld),w.extractRotation(n.matrixWorld),b.set(0,0,1),b.applyMatrix4(w),M.subVectors(y,E),M.dot(b)>0)return;M.reflect(b).negate(),M.add(y),w.extractRotation(o.matrixWorld),x.set(0,0,-1),x.applyMatrix4(w),x.add(E),S.subVectors(y,x),S.reflect(b).negate(),S.add(y),T.position.copy(M),T.up.set(0,1,0),T.up.applyMatrix4(w),T.up.reflect(b),T.lookAt(S),T.far=o.far,T.updateMatrixWorld(),T.projectionMatrix.copy(o.projectionMatrix),O.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),O.multiply(T.projectionMatrix),O.multiply(T.matrixWorldInverse),g.setFromNormalAndCoplanarPoint(b,y),g.applyMatrix4(T.matrixWorldInverse),P.set(g.normal.x,g.normal.y,g.normal.z,g.constant);const a=T.projectionMatrix;C.x=(Math.sign(P.x)+a.elements[8])/a.elements[0],C.y=(Math.sign(P.y)+a.elements[9])/a.elements[5],C.z=-1,C.w=(1+a.elements[10])/a.elements[14],P.multiplyScalar(2/P.dot(C)),a.elements[2]=P.x,a.elements[6]=P.y,a.elements[10]=P.z+1-r,a.elements[14]=P.w,p.setFromMatrixPosition(o.matrixWorld);const i=e.getRenderTarget(),s=e.xr.enabled,c=e.shadowMap.autoUpdate;n.visible=!1,e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(A),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,T),n.visible=!0,e.xr.enabled=s,e.shadowMap.autoUpdate=c,e.setRenderTarget(i);const l=o.viewport;void 0!==l&&e.state.viewport(l)}}}}}]);
//# sourceMappingURL=4150.094a5f49.chunk.js.map