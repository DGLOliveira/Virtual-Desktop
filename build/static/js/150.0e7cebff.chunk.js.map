{"version":3,"file":"static/js/150.0e7cebff.chunk.js","mappings":"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","sources":["../node_modules/src/controls/OrbitControls.ts","../node_modules/@react-three/drei/core/OrbitControls.js","../node_modules/src/objects/Sky.ts","../node_modules/@react-three/drei/core/Sky.js","../node_modules/@react-three/drei/helpers/constants.js","../node_modules/@react-three/drei/core/Stars.js","../node_modules/@react-three/drei/core/shapes.js","../node_modules/src/objects/Water.js"],"sourcesContent":["import {\n  EventDispatcher,\n  Matrix4,\n  MOUSE,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n  Ray,\n  Plane,\n} from 'three'\n\nconst _ray = new Ray()\nconst _plane = new Plane()\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180))\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst moduloWrapAround = (offset: number, capacity: number) => ((offset % capacity) + capacity) % capacity\n\nclass OrbitControls extends EventDispatcher {\n  object: PerspectiveCamera | OrthographicCamera\n  domElement: HTMLElement | undefined\n  // Set to false to disable this control\n  enabled = true\n  // \"target\" sets the location of focus, where the object orbits around\n  target = new Vector3()\n  // How far you can dolly in and out ( PerspectiveCamera only )\n  minDistance = 0\n  maxDistance = Infinity\n  // How far you can zoom in and out ( OrthographicCamera only )\n  minZoom = 0\n  maxZoom = Infinity\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  minPolarAngle = 0 // radians\n  maxPolarAngle = Math.PI // radians\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n  minAzimuthAngle = -Infinity // radians\n  maxAzimuthAngle = Infinity // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n  enableDamping = false\n  dampingFactor = 0.05\n  // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n  // Set to false to disable zooming\n  enableZoom = true\n  zoomSpeed = 1.0\n  // Set to false to disable rotating\n  enableRotate = true\n  rotateSpeed = 1.0\n  // Set to false to disable panning\n  enablePan = true\n  panSpeed = 1.0\n  screenSpacePanning = true // if false, pan orthogonal to world-space direction camera.up\n  keyPanSpeed = 7.0 // pixels moved per arrow key push\n  zoomToCursor = false\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n  autoRotate = false\n  autoRotateSpeed = 2.0 // 30 seconds per orbit when fps is 60\n  reverseOrbit = false // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n  reverseHorizontalOrbit = false // true if you want to reverse the horizontal orbit direction\n  reverseVerticalOrbit = false // true if you want to reverse the vertical orbit direction\n  // The four arrow keys\n  keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }\n  // Mouse buttons\n  mouseButtons: Partial<{\n    LEFT: MOUSE\n    MIDDLE: MOUSE\n    RIGHT: MOUSE\n  }> = {\n    LEFT: MOUSE.ROTATE,\n    MIDDLE: MOUSE.DOLLY,\n    RIGHT: MOUSE.PAN,\n  }\n  // Touch fingers\n  touches: Partial<{\n    ONE: TOUCH\n    TWO: TOUCH\n  }> = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }\n  target0: Vector3\n  position0: Vector3\n  zoom0: number\n  // the target DOM element for key events\n  _domElementKeyEvents: any = null\n\n  getPolarAngle: () => number\n  getAzimuthalAngle: () => number\n  setPolarAngle: (x: number) => void\n  setAzimuthalAngle: (x: number) => void\n  getDistance: () => number\n  // Not used in most scenarios, however they can be useful for specific use cases\n  getZoomScale: () => number\n\n  listenToKeyEvents: (domElement: HTMLElement) => void\n  stopListenToKeyEvents: () => void\n  saveState: () => void\n  reset: () => void\n  update: () => void\n  connect: (domElement: HTMLElement) => void\n  dispose: () => void\n\n  // Dolly in programmatically\n  dollyIn: (dollyScale?: number) => void\n  // Dolly out programmatically\n  dollyOut: (dollyScale?: number) => void\n  // Get the current scale\n  getScale: () => number\n  // Set the current scale (these are not used in most scenarios, however they can be useful for specific use cases)\n  setScale: (newScale: number) => void\n  \n\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super()\n\n    this.object = object\n    this.domElement = domElement\n\n    // for reset\n    this.target0 = this.target.clone()\n    this.position0 = this.object.position.clone()\n    this.zoom0 = this.object.zoom\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = (): number => spherical.phi\n\n    this.getAzimuthalAngle = (): number => spherical.theta\n\n    this.setPolarAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let phi = moduloWrapAround(value, 2 * Math.PI)\n      let currentPhi = spherical.phi\n\n      // convert to the equivalent shortest angle\n      if (currentPhi < 0) currentPhi += 2 * Math.PI\n      if (phi < 0) phi += 2 * Math.PI\n      let phiDist = Math.abs(phi - currentPhi)\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI\n        } else {\n          currentPhi += 2 * Math.PI\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi\n      scope.update()\n    }\n\n    this.setAzimuthalAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let theta = moduloWrapAround(value, 2 * Math.PI)\n      let currentTheta = spherical.theta\n\n      // convert to the equivalent shortest angle\n      if (currentTheta < 0) currentTheta += 2 * Math.PI\n      if (theta < 0) theta += 2 * Math.PI\n      let thetaDist = Math.abs(theta - currentTheta)\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI\n        } else {\n          currentTheta += 2 * Math.PI\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta\n      scope.update()\n    }\n\n    this.getDistance = (): number => scope.object.position.distanceTo(scope.target)\n\n    this.listenToKeyEvents = (domElement: HTMLElement): void => {\n      domElement.addEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = domElement\n    }\n\n    this.stopListenToKeyEvents = (): void => {\n      this._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = null\n    }\n\n    this.saveState = (): void => {\n      scope.target0.copy(scope.target)\n      scope.position0.copy(scope.object.position)\n      scope.zoom0 = scope.object.zoom\n    }\n\n    this.reset = (): void => {\n      scope.target.copy(scope.target0)\n      scope.object.position.copy(scope.position0)\n      scope.object.zoom = scope.zoom0\n      scope.object.updateProjectionMatrix()\n\n      // @ts-ignore\n      scope.dispatchEvent(changeEvent)\n\n      scope.update()\n\n      state = STATE.NONE\n    }\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = ((): (() => void) => {\n      const offset = new Vector3()\n      const up = new Vector3(0, 1, 0)\n\n      // so camera.up is the orbit axis\n      const quat = new Quaternion().setFromUnitVectors(object.up, up)\n      const quatInverse = quat.clone().invert()\n\n      const lastPosition = new Vector3()\n      const lastQuaternion = new Quaternion()\n\n      const twoPI = 2 * Math.PI\n\n      return function update(): boolean {\n        const position = scope.object.position\n\n        // update new up direction\n        quat.setFromUnitVectors(object.up, up)\n        quatInverse.copy(quat).invert()\n\n        offset.copy(position).sub(scope.target)\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat)\n\n        // angle from z-axis around y-axis\n        spherical.setFromVector3(offset)\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle())\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor\n        } else {\n          spherical.theta += sphericalDelta.theta\n          spherical.phi += sphericalDelta.phi\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = scope.minAzimuthAngle\n        let max = scope.maxAzimuthAngle\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI\n          else if (min > Math.PI) min -= twoPI\n\n          if (max < -Math.PI) max += twoPI\n          else if (max > Math.PI) max -= twoPI\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta))\n          } else {\n            spherical.theta =\n              spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta)\n          }\n        }\n\n        // restrict phi to be between desired limits\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi))\n        spherical.makeSafe()\n\n        // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor)\n        } else {\n          scope.target.add(panOffset)\n        }\n\n        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n        // we adjust zoom later in these cases\n        if ((scope.zoomToCursor && performCursorZoom) || (scope.object as OrthographicCamera).isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius)\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale)\n        }\n\n        offset.setFromSpherical(spherical)\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse)\n\n        position.copy(scope.target).add(offset)\n\n        if (!scope.object.matrixAutoUpdate) scope.object.updateMatrix()\n        scope.object.lookAt(scope.target)\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor\n          sphericalDelta.phi *= 1 - scope.dampingFactor\n\n          panOffset.multiplyScalar(1 - scope.dampingFactor)\n        } else {\n          sphericalDelta.set(0, 0, 0)\n\n          panOffset.set(0, 0, 0)\n        }\n\n        // adjust camera position\n        let zoomChanged = false\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null\n          if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            // move the camera down the pointer ray\n            // this method avoids floating point error\n            const prevRadius = offset.length()\n            newRadius = clampDistance(prevRadius * scale)\n\n            const radiusDelta = prevRadius - newRadius\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta)\n            scope.object.updateMatrixWorld()\n          } else if ((scope.object as OrthographicCamera).isOrthographicCamera) {\n            // adjust the ortho camera position based on zoom changes\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0)\n            mouseBefore.unproject(scope.object)\n\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n            zoomChanged = true\n\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0)\n            mouseAfter.unproject(scope.object)\n\n            scope.object.position.sub(mouseAfter).add(mouseBefore)\n            scope.object.updateMatrixWorld()\n\n            newRadius = offset.length()\n          } else {\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.')\n            scope.zoomToCursor = false\n          }\n\n          // handle the placement of the target\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              // position the orbit target in front of the new camera position\n              scope.target\n                .set(0, 0, -1)\n                .transformDirection(scope.object.matrix)\n                .multiplyScalar(newRadius)\n                .add(scope.object.position)\n            } else {\n              // get the ray and translation plane to compute target\n              _ray.origin.copy(scope.object.position)\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix)\n\n              // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n              // extremely large values\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target)\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target)\n                _ray.intersectPlane(_plane, scope.target)\n              }\n            }\n          }\n        } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1\n\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n          }\n        }\n\n        scale = 1\n        performCursorZoom = false\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n          zoomChanged ||\n          lastPosition.distanceToSquared(scope.object.position) > EPS ||\n          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n        ) {\n          // @ts-ignore\n          scope.dispatchEvent(changeEvent)\n\n          lastPosition.copy(scope.object.position)\n          lastQuaternion.copy(scope.object.quaternion)\n          zoomChanged = false\n\n          return true\n        }\n\n        return false\n      }\n    })()\n\n    // https://github.com/mrdoob/three.js/issues/20575\n    this.connect = (domElement: HTMLElement): void => {\n      scope.domElement = domElement\n      // disables touch scroll\n      // touch-action needs to be defined for pointer events to work on mobile\n      // https://stackoverflow.com/a/48254578\n      scope.domElement.style.touchAction = 'none'\n      scope.domElement.addEventListener('contextmenu', onContextMenu)\n      scope.domElement.addEventListener('pointerdown', onPointerDown)\n      scope.domElement.addEventListener('pointercancel', onPointerUp)\n      scope.domElement.addEventListener('wheel', onMouseWheel)\n    }\n\n    this.dispose = (): void => {\n      // Enabling touch scroll\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = 'auto'\n      }\n      scope.domElement?.removeEventListener('contextmenu', onContextMenu)\n      scope.domElement?.removeEventListener('pointerdown', onPointerDown)\n      scope.domElement?.removeEventListener('pointercancel', onPointerUp)\n      scope.domElement?.removeEventListener('wheel', onMouseWheel)\n      scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n      scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      }\n      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    }\n\n    //\n    // internals\n    //\n\n    const scope = this\n\n    const changeEvent = { type: 'change' }\n    const startEvent = { type: 'start' }\n    const endEvent = { type: 'end' }\n\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6,\n    }\n\n    let state = STATE.NONE\n\n    const EPS = 0.000001\n\n    // current position in spherical coordinates\n    const spherical = new Spherical()\n    const sphericalDelta = new Spherical()\n\n    let scale = 1\n    const panOffset = new Vector3()\n\n    const rotateStart = new Vector2()\n    const rotateEnd = new Vector2()\n    const rotateDelta = new Vector2()\n\n    const panStart = new Vector2()\n    const panEnd = new Vector2()\n    const panDelta = new Vector2()\n\n    const dollyStart = new Vector2()\n    const dollyEnd = new Vector2()\n    const dollyDelta = new Vector2()\n\n    const dollyDirection = new Vector3()\n    const mouse = new Vector2()\n    let performCursorZoom = false\n\n    const pointers: PointerEvent[] = []\n    const pointerPositions: { [key: string]: Vector2 } = {}\n\n    function getAutoRotationAngle(): number {\n      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed\n    }\n\n    function getZoomScale(): number {\n      return Math.pow(0.95, scope.zoomSpeed)\n    }\n\n    function rotateLeft(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle\n      } else {\n        sphericalDelta.theta -= angle\n      }\n    }\n\n    function rotateUp(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle\n      } else {\n        sphericalDelta.phi -= angle\n      }\n    }\n\n    const panLeft = (() => {\n      const v = new Vector3()\n\n      return function panLeft(distance: number, objectMatrix: Matrix4) {\n        v.setFromMatrixColumn(objectMatrix, 0) // get X column of objectMatrix\n        v.multiplyScalar(-distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    const panUp = (() => {\n      const v = new Vector3()\n\n      return function panUp(distance: number, objectMatrix: Matrix4) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1)\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0)\n          v.crossVectors(scope.object.up, v)\n        }\n\n        v.multiplyScalar(distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    const pan = (() => {\n      const offset = new Vector3()\n\n      return function pan(deltaX: number, deltaY: number) {\n        const element = scope.domElement\n\n        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          // perspective\n          const position = scope.object.position\n          offset.copy(position).sub(scope.target)\n          let targetDistance = offset.length()\n\n          // half of the fov is center to top of screen\n          targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0)\n\n          // we use only clientHeight here so aspect ratio does not distort speed\n          panLeft((2 * deltaX * targetDistance) / element.clientHeight, scope.object.matrix)\n          panUp((2 * deltaY * targetDistance) / element.clientHeight, scope.object.matrix)\n        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(\n            (deltaX * (scope.object.right - scope.object.left)) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix,\n          )\n          panUp(\n            (deltaY * (scope.object.top - scope.object.bottom)) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix,\n          )\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.')\n          scope.enablePan = false\n        }\n      }\n    })()\n\n    function setScale(newScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale = newScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function dollyOut(dollyScale: number) {\n      setScale(scale / dollyScale)\n    }\n\n    function dollyIn(dollyScale: number) {\n      setScale(scale * dollyScale)\n    }\n\n    function updateMouseParameters(event: MouseEvent): void {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return\n      }\n\n      performCursorZoom = true\n\n      const rect = scope.domElement.getBoundingClientRect()\n      const x = event.clientX - rect.left\n      const y = event.clientY - rect.top\n      const w = rect.width\n      const h = rect.height\n\n      mouse.x = (x / w) * 2 - 1\n      mouse.y = -(y / h) * 2 + 1\n\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize()\n    }\n\n    function clampDistance(dist: number): number {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist))\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event: MouseEvent) {\n      rotateStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownDolly(event: MouseEvent) {\n      updateMouseParameters(event)\n      dollyStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownPan(event: MouseEvent) {\n      panStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseMoveRotate(event: MouseEvent) {\n      rotateEnd.set(event.clientX, event.clientY)\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n      scope.update()\n    }\n\n    function handleMouseMoveDolly(event: MouseEvent) {\n      dollyEnd.set(event.clientX, event.clientY)\n      dollyDelta.subVectors(dollyEnd, dollyStart)\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale())\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale())\n      }\n\n      dollyStart.copy(dollyEnd)\n      scope.update()\n    }\n\n    function handleMouseMovePan(event: MouseEvent) {\n      panEnd.set(event.clientX, event.clientY)\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n      scope.update()\n    }\n\n    function handleMouseWheel(event: WheelEvent) {\n      updateMouseParameters(event)\n\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale())\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale())\n      }\n\n      scope.update()\n    }\n\n    function handleKeyDown(event: KeyboardEvent) {\n      let needsUpdate = false\n\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault()\n        scope.update()\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        rotateStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        panStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX\n      const dy = pointers[0].pageY - pointers[1].pageY\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyStart.set(0, distance)\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enablePan) handleTouchStartPan()\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enableRotate) handleTouchStartRotate()\n    }\n\n    function handleTouchMoveRotate(event: PointerEvent) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        rotateEnd.set(x, y)\n      }\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n    }\n\n    function handleTouchMovePan(event: PointerEvent) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        panEnd.set(x, y)\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n    }\n\n    function handleTouchMoveDolly(event: PointerEvent) {\n      const position = getSecondPointerPosition(event)\n      const dx = event.pageX - position.x\n      const dy = event.pageY - position.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyEnd.set(0, distance)\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed))\n      dollyOut(dollyDelta.y)\n      dollyStart.copy(dollyEnd)\n    }\n\n    function handleTouchMoveDollyPan(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enablePan) handleTouchMovePan(event)\n    }\n\n    function handleTouchMoveDollyRotate(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enableRotate) handleTouchMoveRotate(event)\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (pointers.length === 0) {\n        scope.domElement?.ownerDocument.addEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.addEventListener('pointerup', onPointerUp)\n      }\n\n      addPointer(event)\n\n      if (event.pointerType === 'touch') {\n        onTouchStart(event)\n      } else {\n        onMouseDown(event)\n      }\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (event.pointerType === 'touch') {\n        onTouchMove(event)\n      } else {\n        onMouseMove(event)\n      }\n    }\n\n    function onPointerUp(event: PointerEvent) {\n      removePointer(event)\n\n      if (pointers.length === 0) {\n        scope.domElement?.releasePointerCapture(event.pointerId)\n\n        scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      }\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n\n      state = STATE.NONE\n    }\n\n    function onMouseDown(event: MouseEvent) {\n      let mouseAction\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT\n          break\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE\n          break\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT\n          break\n\n        default:\n          mouseAction = -1\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseDownDolly(event)\n          state = STATE.DOLLY\n          break\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          } else {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          }\n          break\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          } else {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          }\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onMouseMove(event: MouseEvent) {\n      if (scope.enabled === false) return\n\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return\n          handleMouseMoveRotate(event)\n          break\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseMoveDolly(event)\n          break\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return\n          handleMouseMovePan(event)\n          break\n      }\n    }\n\n    function onMouseWheel(event: WheelEvent) {\n      if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) {\n        return\n      }\n\n      event.preventDefault()\n\n      // @ts-ignore\n      scope.dispatchEvent(startEvent)\n\n      handleMouseWheel(event)\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n    }\n\n    function onKeyDown(event: KeyboardEvent) {\n      if (scope.enabled === false || scope.enablePan === false) return\n      handleKeyDown(event)\n    }\n\n    function onTouchStart(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return\n              handleTouchStartRotate()\n              state = STATE.TOUCH_ROTATE\n              break\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return\n              handleTouchStartPan()\n              state = STATE.TOUCH_PAN\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false) return\n              handleTouchStartDollyPan()\n              state = STATE.TOUCH_DOLLY_PAN\n              break\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false) return\n              handleTouchStartDollyRotate()\n              state = STATE.TOUCH_DOLLY_ROTATE\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onTouchMove(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return\n          handleTouchMoveRotate(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return\n          handleTouchMovePan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return\n          handleTouchMoveDollyPan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false) return\n          handleTouchMoveDollyRotate(event)\n          scope.update()\n          break\n\n        default:\n          state = STATE.NONE\n      }\n    }\n\n    function onContextMenu(event: Event) {\n      if (scope.enabled === false) return\n      event.preventDefault()\n    }\n\n    function addPointer(event: PointerEvent) {\n      pointers.push(event)\n    }\n\n    function removePointer(event: PointerEvent) {\n      delete pointerPositions[event.pointerId]\n\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1)\n          return\n        }\n      }\n    }\n\n    function trackPointer(event: PointerEvent) {\n      let position = pointerPositions[event.pointerId]\n\n      if (position === undefined) {\n        position = new Vector2()\n        pointerPositions[event.pointerId] = position\n      }\n\n      position.set(event.pageX, event.pageY)\n    }\n\n    function getSecondPointerPosition(event: PointerEvent) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0]\n      return pointerPositions[pointer.pointerId]\n    }\n\n    // Add dolly in/out methods for public API\n\n    this.dollyIn = (dollyScale = getZoomScale()) => {\n      dollyIn(dollyScale)\n      scope.update()\n    }\n\n    this.dollyOut = (dollyScale = getZoomScale()) => {\n        dollyOut(dollyScale)\n        scope.update()\n    }\n\n    this.getScale = () => {\n        return scale;\n    }\n\n    this.setScale = (newScale) => {\n        setScale(newScale)\n        scope.update()\n    }\n\n    this.getZoomScale = () => {\n        return getZoomScale();\n    }\n\n    // connect events\n    if (domElement !== undefined) this.connect(domElement)\n    // force an update at start\n    this.update()\n  }\n}\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super(object, domElement)\n\n    this.screenSpacePanning = false // pan orthogonal to world-space direction camera.up\n\n    this.mouseButtons.LEFT = MOUSE.PAN\n    this.mouseButtons.RIGHT = MOUSE.ROTATE\n\n    this.touches.ONE = TOUCH.PAN\n    this.touches.TWO = TOUCH.DOLLY_ROTATE\n  }\n}\n\nexport { OrbitControls, MapControls }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport { OrbitControls as OrbitControls$1 } from 'three-stdlib';\n\nconst OrbitControls = /* @__PURE__ */React.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  keyEvents = false,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = useThree(state => state.invalidate);\n  const defaultCamera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const events = useThree(state => state.events);\n  const setEvents = useThree(state => state.setEvents);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const performance = useThree(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = React.useMemo(() => new OrbitControls$1(explCamera), [explCamera]);\n  useFrame(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  React.useEffect(() => {\n    if (keyEvents) {\n      controls.connect(keyEvents === true ? explDomElement : keyEvents);\n    }\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [keyEvents, explDomElement, regress, controls, invalidate]);\n  React.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n    const onStartCb = e => {\n      if (onStart) onStart(e);\n    };\n    const onEndCb = e => {\n      if (onEnd) onEnd(e);\n    };\n    controls.addEventListener('change', callback);\n    controls.addEventListener('start', onStartCb);\n    controls.addEventListener('end', onEndCb);\n    return () => {\n      controls.removeEventListener('start', onStartCb);\n      controls.removeEventListener('end', onEndCb);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);\n  React.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\nexport { OrbitControls };\n","import { BackSide, BoxGeometry, Mesh, ShaderMaterial, UniformsUtils, Vector3 } from 'three'\nimport { version } from '../_polyfill/constants'\n\nconst SkyShader = {\n  uniforms: {\n    turbidity: { value: 2 },\n    rayleigh: { value: 1 },\n    mieCoefficient: { value: 0.005 },\n    mieDirectionalG: { value: 0.8 },\n    sunPosition: { value: new Vector3() },\n    up: { value: new Vector3(0, 1, 0) },\n  },\n\n  vertexShader: /* glsl */ `\n      uniform vec3 sunPosition;\n      uniform float rayleigh;\n      uniform float turbidity;\n      uniform float mieCoefficient;\n      uniform vec3 up;\n\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      // constants for atmospheric scattering\n      const float e = 2.71828182845904523536028747135266249775724709369995957;\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      // wavelength of used primaries, according to preetham\n      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n      // mie stuff\n      // K coefficient for the primaries\n      const float v = 4.0;\n      const vec3 K = vec3( 0.686, 0.678, 0.666 );\n      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n      // earth shadow hack\n      // cutoffAngle = pi / 1.95;\n      const float cutoffAngle = 1.6110731556870734;\n      const float steepness = 1.5;\n      const float EE = 1000.0;\n\n      float sunIntensity( float zenithAngleCos ) {\n        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n      }\n\n      vec3 totalMie( float T ) {\n        float c = ( 0.2 * T ) * 10E-18;\n        return 0.434 * c * MieConst;\n      }\n\n      void main() {\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        gl_Position.z = gl_Position.w; // set z to camera.far\n\n        vSunDirection = normalize( sunPosition );\n\n        vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n      // extinction (absorbtion + out scattering)\n      // rayleigh coefficients\n        vBetaR = totalRayleigh * rayleighCoefficient;\n\n      // mie coefficients\n        vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n      }\n    `,\n\n  fragmentShader: /* glsl */ `\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      uniform float mieDirectionalG;\n      uniform vec3 up;\n\n      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n      // constants for atmospheric scattering\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      const float n = 1.0003; // refractive index of air\n      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n      // optical length at zenith for molecules\n      const float rayleighZenithLength = 8.4E3;\n      const float mieZenithLength = 1.25E3;\n      // 66 arc seconds -> degrees, and the cosine of that\n      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n      // 3.0 / ( 16.0 * pi )\n      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n      // 1.0 / ( 4.0 * pi )\n      const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n      float rayleighPhase( float cosTheta ) {\n        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n      }\n\n      float hgPhase( float cosTheta, float g ) {\n        float g2 = pow( g, 2.0 );\n        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n      }\n\n      void main() {\n\n        vec3 direction = normalize( vWorldPosition - cameraPos );\n\n      // optical length\n      // cutoff angle at 90 to avoid singularity in next formula.\n        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n        float sR = rayleighZenithLength * inverse;\n        float sM = mieZenithLength * inverse;\n\n      // combined extinction factor\n        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n      // in scattering\n        float cosTheta = dot( direction, vSunDirection );\n\n        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n        vec3 betaRTheta = vBetaR * rPhase;\n\n        float mPhase = hgPhase( cosTheta, mieDirectionalG );\n        vec3 betaMTheta = vBetaM * mPhase;\n\n        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n      // nightsky\n        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]\n        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]\n        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n        vec3 L0 = vec3( 0.1 ) * Fex;\n\n      // composition + solar disc\n        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n        gl_FragColor = vec4( retColor, 1.0 );\n\n      #include <tonemapping_fragment>\n      #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\n      }\n    `,\n}\n\nconst material = new ShaderMaterial({\n  name: 'SkyShader',\n  fragmentShader: SkyShader.fragmentShader,\n  vertexShader: SkyShader.vertexShader,\n  uniforms: UniformsUtils.clone(SkyShader.uniforms),\n  side: BackSide,\n  depthWrite: false,\n})\n\n/**\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n */\nclass Sky extends Mesh {\n  constructor() {\n    super(new BoxGeometry(1, 1, 1), material)\n  }\n\n  static SkyShader = SkyShader\n  public static material = material\n}\n\nexport { Sky }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Sky as Sky$1 } from 'three-stdlib';\nimport { Vector3 } from 'three';\n\nfunction calcPosFromAngles(inclination, azimuth, vector = new Vector3()) {\n  const theta = Math.PI * (inclination - 0.5);\n  const phi = 2 * Math.PI * (azimuth - 0.5);\n  vector.x = Math.cos(phi);\n  vector.y = Math.sin(theta);\n  vector.z = Math.sin(phi);\n  return vector;\n}\nconst Sky = /* @__PURE__ */React.forwardRef(({\n  inclination = 0.6,\n  azimuth = 0.1,\n  distance = 1000,\n  mieCoefficient = 0.005,\n  mieDirectionalG = 0.8,\n  rayleigh = 0.5,\n  turbidity = 10,\n  sunPosition = calcPosFromAngles(inclination, azimuth),\n  ...props\n}, ref) => {\n  const scale = React.useMemo(() => new Vector3().setScalar(distance), [distance]);\n  const [sky] = React.useState(() => new Sky$1());\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: sky,\n    ref: ref,\n    \"material-uniforms-mieCoefficient-value\": mieCoefficient,\n    \"material-uniforms-mieDirectionalG-value\": mieDirectionalG,\n    \"material-uniforms-rayleigh-value\": rayleigh,\n    \"material-uniforms-sunPosition-value\": sunPosition,\n    \"material-uniforms-turbidity-value\": turbidity,\n    scale: scale\n  }, props));\n});\n\nexport { Sky, calcPosFromAngles };\n","import { REVISION } from 'three';\n\nconst getVersion = () => parseInt(REVISION.replace(/\\D+/g, ''));\nconst version = /* @__PURE__ */getVersion();\n\nexport { version };\n","import * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { Color, AdditiveBlending, ShaderMaterial, Vector3, Spherical } from 'three';\nimport { version } from '../helpers/constants.js';\n\nclass StarfieldMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        time: {\n          value: 0.0\n        },\n        fade: {\n          value: 1.0\n        }\n      },\n      vertexShader: /* glsl */`\n      uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }`,\n      fragmentShader: /* glsl */`\n      uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n\n        #include <tonemapping_fragment>\n\t      #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n      }`\n    });\n  }\n}\nconst genStar = r => {\n  return new Vector3().setFromSpherical(new Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));\n};\nconst Stars = /* @__PURE__ */React.forwardRef(({\n  radius = 100,\n  depth = 50,\n  count = 5000,\n  saturation = 0,\n  factor = 4,\n  fade = false,\n  speed = 1\n}, ref) => {\n  const material = React.useRef();\n  const [position, color, size] = React.useMemo(() => {\n    const positions = [];\n    const colors = [];\n    const sizes = Array.from({\n      length: count\n    }, () => (0.5 + 0.5 * Math.random()) * factor);\n    const color = new Color();\n    let r = radius + depth;\n    const increment = depth / count;\n    for (let i = 0; i < count; i++) {\n      r -= increment * Math.random();\n      positions.push(...genStar(r).toArray());\n      color.setHSL(i / count, saturation, 0.9);\n      colors.push(color.r, color.g, color.b);\n    }\n    return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];\n  }, [count, depth, factor, radius, saturation]);\n  useFrame(state => material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime() * speed));\n  const [starfieldMaterial] = React.useState(() => new StarfieldMaterial());\n  return /*#__PURE__*/React.createElement(\"points\", {\n    ref: ref\n  }, /*#__PURE__*/React.createElement(\"bufferGeometry\", null, /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-position\",\n    args: [position, 3]\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-color\",\n    args: [color, 3]\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-size\",\n    args: [size, 1]\n  })), /*#__PURE__*/React.createElement(\"primitive\", {\n    ref: material,\n    object: starfieldMaterial,\n    attach: \"material\",\n    blending: AdditiveBlending,\n    \"uniforms-fade-value\": fade,\n    depthWrite: false,\n    transparent: true,\n    vertexColors: true\n  }));\n});\n\nexport { Stars };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\n\nfunction create(type, effect) {\n  const El = type + 'Geometry';\n  return /*#__PURE__*/React.forwardRef(({\n    args,\n    children,\n    ...props\n  }, fref) => {\n    const ref = React.useRef(null);\n    React.useImperativeHandle(fref, () => ref.current);\n    React.useLayoutEffect(() => void (effect == null ? void 0 : effect(ref.current)));\n    return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n      ref: ref\n    }, props), /*#__PURE__*/React.createElement(El, {\n      attach: \"geometry\",\n      args: args\n    }), children);\n  });\n}\nconst Box = /* @__PURE__ */create('box');\nconst Circle = /* @__PURE__ */create('circle');\nconst Cone = /* @__PURE__ */create('cone');\nconst Cylinder = /* @__PURE__ */create('cylinder');\nconst Sphere = /* @__PURE__ */create('sphere');\nconst Plane = /* @__PURE__ */create('plane');\nconst Tube = /* @__PURE__ */create('tube');\nconst Torus = /* @__PURE__ */create('torus');\nconst TorusKnot = /* @__PURE__ */create('torusKnot');\nconst Tetrahedron = /* @__PURE__ */create('tetrahedron');\nconst Ring = /* @__PURE__ */create('ring');\nconst Polyhedron = /* @__PURE__ */create('polyhedron');\nconst Icosahedron = /* @__PURE__ */create('icosahedron');\nconst Octahedron = /* @__PURE__ */create('octahedron');\nconst Dodecahedron = /* @__PURE__ */create('dodecahedron');\nconst Extrude = /* @__PURE__ */create('extrude');\nconst Lathe = /* @__PURE__ */create('lathe');\nconst Capsule = /* @__PURE__ */create('capsule');\nconst Shape = /* @__PURE__ */create('shape', ({\n  geometry\n}) => {\n  // Calculate UVs (by https://discourse.threejs.org/u/prisoner849)\n  // https://discourse.threejs.org/t/custom-shape-in-image-not-working/49348/10\n  const pos = geometry.attributes.position;\n  const b3 = new THREE.Box3().setFromBufferAttribute(pos);\n  const b3size = new THREE.Vector3();\n  b3.getSize(b3size);\n  const uv = [];\n  let x = 0,\n    y = 0,\n    u = 0,\n    v = 0;\n  for (let i = 0; i < pos.count; i++) {\n    x = pos.getX(i);\n    y = pos.getY(i);\n    u = (x - b3.min.x) / b3size.x;\n    v = (y - b3.min.y) / b3size.y;\n    uv.push(u, v);\n  }\n  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));\n});\n\nexport { Box, Capsule, Circle, Cone, Cylinder, Dodecahedron, Extrude, Icosahedron, Lathe, Octahedron, Plane, Polyhedron, Ring, Shape, Sphere, Tetrahedron, Torus, TorusKnot, Tube };\n","import {\n  Color,\n  FrontSide,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  Plane,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector3,\n  Vector4,\n  WebGLRenderTarget,\n  REVISION,\n} from 'three'\n\n/**\n * Work based on :\n * https://github.com/Slayvin: Flat mirror for three.js\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isWater = true\n\n    const scope = this\n\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512\n\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0\n    const alpha = options.alpha !== undefined ? options.alpha : 1.0\n    const time = options.time !== undefined ? options.time : 0.0\n    const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null\n    const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0)\n    const sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff)\n    const waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f)\n    const eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0)\n    const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0\n    const side = options.side !== undefined ? options.side : FrontSide\n    const fog = options.fog !== undefined ? options.fog : false\n\n    //\n\n    const mirrorPlane = new Plane()\n    const normal = new Vector3()\n    const mirrorWorldPosition = new Vector3()\n    const cameraWorldPosition = new Vector3()\n    const rotationMatrix = new Matrix4()\n    const lookAtPosition = new Vector3(0, 0, -1)\n    const clipPlane = new Vector4()\n\n    const view = new Vector3()\n    const target = new Vector3()\n    const q = new Vector4()\n\n    const textureMatrix = new Matrix4()\n\n    const mirrorCamera = new PerspectiveCamera()\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight)\n\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([\n        UniformsLib['fog'],\n        UniformsLib['lights'],\n        {\n          normalSampler: { value: null },\n          mirrorSampler: { value: null },\n          alpha: { value: 1.0 },\n          time: { value: 0.0 },\n          size: { value: 1.0 },\n          distortionScale: { value: 20.0 },\n          textureMatrix: { value: new Matrix4() },\n          sunColor: { value: new Color(0x7f7f7f) },\n          sunDirection: { value: new Vector3(0.70707, 0.70707, 0) },\n          eye: { value: new Vector3() },\n          waterColor: { value: new Color(0x555555) },\n        },\n      ]),\n\n      vertexShader: /* glsl */ `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n\n      fragmentShader: /* glsl */ `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\t\t\t\t\t#include <fog_fragment>\t\n\t\t\t\t}`,\n    }\n\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog,\n    })\n\n    material.uniforms['mirrorSampler'].value = renderTarget.texture\n    material.uniforms['textureMatrix'].value = textureMatrix\n    material.uniforms['alpha'].value = alpha\n    material.uniforms['time'].value = time\n    material.uniforms['normalSampler'].value = normalSampler\n    material.uniforms['sunColor'].value = sunColor\n    material.uniforms['waterColor'].value = waterColor\n    material.uniforms['sunDirection'].value = sunDirection\n    material.uniforms['distortionScale'].value = distortionScale\n\n    material.uniforms['eye'].value = eye\n\n    scope.material = material\n\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n      rotationMatrix.extractRotation(scope.matrixWorld)\n\n      normal.set(0, 0, 1)\n      normal.applyMatrix4(rotationMatrix)\n\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition)\n\n      // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return\n\n      view.reflect(normal).negate()\n      view.add(mirrorWorldPosition)\n\n      rotationMatrix.extractRotation(camera.matrixWorld)\n\n      lookAtPosition.set(0, 0, -1)\n      lookAtPosition.applyMatrix4(rotationMatrix)\n      lookAtPosition.add(cameraWorldPosition)\n\n      target.subVectors(mirrorWorldPosition, lookAtPosition)\n      target.reflect(normal).negate()\n      target.add(mirrorWorldPosition)\n\n      mirrorCamera.position.copy(view)\n      mirrorCamera.up.set(0, 1, 0)\n      mirrorCamera.up.applyMatrix4(rotationMatrix)\n      mirrorCamera.up.reflect(normal)\n      mirrorCamera.lookAt(target)\n\n      mirrorCamera.far = camera.far // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld()\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix)\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n      textureMatrix.multiply(mirrorCamera.projectionMatrix)\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse)\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition)\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse)\n\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant)\n\n      const projectionMatrix = mirrorCamera.projectionMatrix\n\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0]\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5]\n      q.z = -1.0\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q))\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x\n      projectionMatrix.elements[6] = clipPlane.y\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias\n      projectionMatrix.elements[14] = clipPlane.w\n\n      eye.setFromMatrixPosition(camera.matrixWorld)\n\n      // Render\n\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n\n      scope.visible = false\n\n      renderer.xr.enabled = false // Avoid camera modification and recursion\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget)\n\n      renderer.state.buffers.depth.setMask(true) // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, mirrorCamera)\n\n      scope.visible = true\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n\n      renderer.setRenderTarget(currentRenderTarget)\n\n      // Restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n    }\n  }\n}\n\nexport { Water }\n"],"names":["_ray","Ray","_plane","Plane","TILT_LIMIT","Math","cos","PI","moduloWrapAround","offset","capacity","OrbitControls","EventDispatcher","constructor","object","domElement","__publicField","Vector3","Infinity","LEFT","UP","RIGHT","BOTTOM","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","ONE","TOUCH","TWO","DOLLY_PAN","this","target0","target","clone","position0","position","zoom0","zoom","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","setPolarAngle","value","currentPhi","phiDist","abs","sphericalDelta","scope","update","setAzimuthalAngle","currentTheta","thetaDist","getDistance","distanceTo","listenToKeyEvents","domElement2","addEventListener","onKeyDown","_domElementKeyEvents","stopListenToKeyEvents","removeEventListener","saveState","copy","reset","updateProjectionMatrix","dispatchEvent","changeEvent","state","STATE","NONE","up","quat","Quaternion","setFromUnitVectors","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","autoRotate","rotateLeft","autoRotateSpeed","enableDamping","dampingFactor","min","minAzimuthAngle","max","maxAzimuthAngle","isFinite","minPolarAngle","maxPolarAngle","makeSafe","addScaledVector","panOffset","add","zoomToCursor","performCursorZoom","isOrthographicCamera","radius","clampDistance","scale","setFromSpherical","matrixAutoUpdate","updateMatrix","lookAt","multiplyScalar","set","zoomChanged","newRadius","PerspectiveCamera","isPerspectiveCamera","prevRadius","length","radiusDelta","dollyDirection","updateMatrixWorld","mouseBefore","mouse","x","y","unproject","minZoom","maxZoom","mouseAfter","console","warn","screenSpacePanning","transformDirection","matrix","origin","direction","dot","setFromNormalAndCoplanarPoint","intersectPlane","OrthographicCamera","distanceToSquared","EPS","quaternion","connect","style","touchAction","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","dispose","_a","_b","_c","_d","_e","ownerDocument","onPointerMove","_f","type","startEvent","endEvent","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","pow","zoomSpeed","angle","reverseOrbit","reverseHorizontalOrbit","rotateUp","reverseVerticalOrbit","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","targetDistance","tan","fov","clientHeight","right","left","clientWidth","top","bottom","enablePan","setScale","newScale","enableZoom","dollyOut","dollyScale","dollyIn","updateMouseParameters","event","rect","getBoundingClientRect","clientX","clientY","w","width","h","height","normalize","dist","minDistance","maxDistance","handleMouseDownRotate","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","getSecondPointerPosition","subVectors","rotateSpeed","handleTouchMovePan","panSpeed","handleTouchMoveDolly","enabled","push","addPointer","pointerType","trackPointer","touches","enableRotate","DOLLY_ROTATE","onTouchStart","mouseAction","button","mouseButtons","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","onMouseDown","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","onTouchMove","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","onMouseMove","pointerId","i","splice","removePointer","releasePointerCapture","preventDefault","handleMouseWheel","needsUpdate","code","keys","keyPanSpeed","handleKeyDown","pointer","arguments","undefined","getScale","React","_ref","ref","makeDefault","camera","regress","keyEvents","onChange","onStart","onEnd","restProps","invalidate","useThree","defaultCamera","gl","events","setEvents","get","performance","explCamera","explDomElement","connected","controls","OrbitControls$1","useFrame","callback","e","onStartCb","onEndCb","old","_extends","SkyShader","uniforms","turbidity","rayleigh","mieCoefficient","mieDirectionalG","sunPosition","vertexShader","fragmentShader","version","material","ShaderMaterial","name","UniformsUtils","side","BackSide","depthWrite","Sky","Mesh","super","BoxGeometry","calcPosFromAngles","inclination","azimuth","vector","sin","z","props","setScalar","sky","Sky$1","getVersion","parseInt","REVISION","replace","StarfieldMaterial","time","fade","genStar","r","acos","random","Stars","depth","count","saturation","factor","speed","color","size","positions","colors","sizes","Array","from","Color","increment","toArray","setHSL","g","b","Float32Array","current","clock","getElapsedTime","starfieldMaterial","attach","args","blending","AdditiveBlending","transparent","vertexColors","create","effect","El","fref","children","Water","geometry","options","isWater","textureWidth","textureHeight","clipBias","alpha","normalSampler","waterNormals","sunDirection","sunColor","waterColor","eye","distortionScale","FrontSide","fog","mirrorPlane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","q","textureMatrix","mirrorCamera","renderTarget","WebGLRenderTarget","mirrorShader","merge","UniformsLib","mirrorSampler","lights","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","reflect","negate","far","projectionMatrix","multiply","matrixWorldInverse","constant","sign","elements","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","buffers","setMask","autoClear","clear","render","viewport"],"sourceRoot":""}